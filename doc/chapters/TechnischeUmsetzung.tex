\chapter{Technische Umsetzung und numerische Untersuchungen} \label{kap:TUNU}
Das in Gleichung \eqref{equ:mayer_problem} gezeigte Optimalsteuerungsproblem in \autoref{cha:optim} wird numerisch in \textit{MATLAB} implementiert und gelöst. Im Folgenden Kapitel werden Methoden zur Lösung des Differentialgleichungssystems (vgl. Gleichung \eqref{equ:state_space}) verglichen. Desweiteren werden Algortihmen zur Lösung von nichtlinearen Optimierungsproblemen erläutert. Die Implementierung der Lösung des Optimalsteuerungsproblems wird mit anhand eines Klassendiagrams visualisiert.

\section{Numerische Lösung von gewöhnlichen Differentialgleichungen} \label{sec:num_ode}
Das gezeigte Modell des Flugzeugs wurde durch ein System von gewöhnlichen Differentialgleichungen abgebildet. Um dieses Modell lösen zu können, werden Methoden von \textit{MATLAB} und eigens implementierte Methoden zur Integration verwendet.
Um die Anwendbarkeit der zur Verfügung stehenden Methoden zu überprüfen, wurden diese mit konstanten Werten für die Steuerfunktionen \(T\) und \(C_L\) gelöst. Hierbei wurden die Werte innerhalb ihres physikalisch sinnvollen Bereiches ausgewählt und konstante Werte dem Löser übergeben.

% define new column for ragged right content
\newcolumntype{Z}{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}X}
\begin{table}[htbp]
    \centering
    \caption{Untersuchte Einschrittalgorithmen zur Lösung der Zustandsdifferentialgleichung im Vergleich zum expliziten Euler Verfahren}
    \begin{tabularx}{.9\textwidth}{Zccc}
        \toprule
        \textbf{Algorithmus}        & \textbf{Laufzeit} & \textbf{Laufzeitdifferenz } \\
                                    & \textbf{in \text{[$s$]}} & \textbf{in \text{[$s$]}} \\
        \midrule
        explizites Euler Verfahren  &   0,00708 &   0 \\
        implizites Euler Verfahren  &   0,0185  &   0,0115\\
        \textit{MATLAB} ode23s      &   0,0914  &   0,0843 \\
        \textit{MATLAB} ode45       &   0,529   &   0,522 \\
        RADAU-2A Verafahren         &   1,36    &   1,35 \\
        \bottomrule
    \end{tabularx}
\end{table}

\begin{figure}[htbp]
    \centering 
    \subfloat[\label{fig:methods_d_h}]{\includegraphics{../code/methods/results/methods_plot_d_h}}
    \qquad
    \subfloat[\label{fig:methods_d_gamma}]{\includegraphics{../code/methods/results/methods_plot_d_gamma}} \\

    \subfloat[\label{fig:methods_d_x}]{\includegraphics{../code/methods/results/methods_plot_d_x}}
    \qquad
    \subfloat[\label{fig:methods_d_v}]{\includegraphics{../code/methods/results/methods_plot_d_v}}
    \caption{Lösung des Differentialgleichungsmodells (vgl. \eqref{equ:state_space}). Die vier Zustandgrößen des Vektors wurden mit kontanten Steuerfunktionen \(T\,=\,1259999\,N\) und \(C_L\,=\,1,49\) gelöst.} %
    % \subref{fig:methods_h} zeigt die gleichmäßig steigende Flughöhe mit kleiner Abweichung zwischend en Methoden. \subref{fig:methods_gamma} zeigt den %
    % Anstellwinkel des Flugzeuges mit deutlicher Abweichung zwischen den Algorithmen. \subref{fig:methods_x} zeigt die zurückgelegte Strecke des Flugzeuges.} %
    % \subref{fig:methods_v} zeigt die Geschwindigkeit des Flugzeuges.}
\end{figure}


\paragraph{Explizites Euler Verfahren}
Die vorangeganenen Untersuchungen zeigen, dass sich das explizite Euler Verfahren am Besten mit Hinsicht auf die Laufzeit und die Genauigkeit zur Lösung des gegebenen Optimalsteuerungsproblems eignet. Das Verfahren wurde nach \cite{Brokate2016} in \textit{MATLAB} implementiert.

\section{Beschränkte nichtlineare Optimierungsverfahren}
Bei den direkten Verfahren wird ein Trajektorienoptimierungsproblem durch Umwandlung in ein nichtlineares Programm (NLP) gelöst. Im vorliegenden Projekt wird dabei ein gradientenbasiertes lokales Verfahren verwendet, welches durch die \textit{Optimization Toolbox} von \textit{MATLAB} bereitgestellt wird. Wie der Name schon sagt, verwenden gradientenbasierte Methoden Ableitungen erster und zweiter Ordnung um lokale Minima zu finden. Zwei wichtige gradientenbasierte Methoden zur Lösung von beschränkten nichtlinearen Optimierungsproblemen sind die sequentielle quadratische Programmierung (SQP) und das Innere-Punkte-Verfahren (IP). Beide reduzieren dieses recht komplizierte Problem in einfachere Teilprobleme und lösen diese nacheinander, bis ein lokales Optimum gefunden ist.

SQP-Verfahren lösen eine Folge von quadratischen Programmen (QP), um die Abstiegsrichtung zu finden, daher der Name sequentielle quadratische Programmierung. Das Minimum ist erreicht, wenn die Karush-Kuhn-Tucker (KKT)-Bedingungen erfüllt sind.

Die KKT-Bedingungen sind notwendige Bedingungen erster Ordnung dafür, dass ein Punkt ein Optimum ist, und beschreiben die Beziehung zwischen dem Gradienten der Zielfunktion und dem Gradienten der aktiven Nebenbedingungen. Wenn das Optimum im Inneren der zulässigen Menge liegt, ist die notwendige Bedingung erster Ordnung einfach dieselbe wie im Fall ohne Nebenbedingungen, nämlich, dass der Gradient der Zielfunktion gleich Null ist.

Die \textit{MATLAB}-Funktion fmincon verwendet zwei Varianten der SQP-Methode namens \textit{active-set} und sqp. Diese beiden Algorithmen sind sich sehr ähnlich und verwenden eine Quasi-Newton-Methode, um sich einer Lösung zu nähern, die die KKT-Bedingungen erfüllt. Es handelt sich um ein Quasi-Newton-Verfahren, da die Hesse-Matrix nicht exakt berechnet, sondern durch Approximation, in diesem Fall einer BFGS-Update, angenähert wird. Diese Approximation wird vorgenommen, da die Hesse-Matrix oft nicht vorliegt. Sowohl \textit{active-set} als auch sqp stellen sicher, dass die Hesse-Matrix positiv definit ist, indem sie die BFGS-Methode mit einer positiv definitiven Matrix initialisieren. Diese Eigenschaft der Hesse-Matrix wird dadurch aufrechterhalten, dass der Algorithmus während des BFGS-Updates verschiedene Matrixoperationen verwendet. Weitere Informationen finden Sie im MathWorks Optimization Toolbox User's Guide (2021). Die Bedingung, dass die Hesse-Matrix positiv definit ist, ist zusammen mit den Optimalitätsbedingungen erster Ordnung, die durch die KKT-Bedingungen beschrieben werden, eine notwendige und hinreichende Bedingung für ein Minimum. 

Bei jeder Iteration wird der Gradient mit Hilfe von finiten Differenzen berechnet und die Hesse-Matrix wird aktualisiert. Diese Informationen werden dann verwendet, um ein quadratisches Programm (QP) aufzustellen, das minimiert wird, um die Abstiegsrichtung zu finden.

Zusammenfassend lässt sich sagen, dass das SQP-Verfahren folgende drei Schritte umfasst:
\begin{enumerate}
    \item Berechnung des Gradienten und Aktualisierung der Hesse-Matrix
    \item QP aufstellen und lösen, um die Abstiegsrichtung zu bestimmen
    \item Durchführen einer Liniensuche um eine geeignete Schrittlänge zu finden
\end{enumerate}

Das Innere-Punkt-Verfahren, auch Barrieremethode genannt, löst sukzessive eine Folge von angenäherten Minimierungsproblemen. Der Ansatz besteht in der Umordnung des ursprünglichen Problems unter Verwendung einer Barrierefunktion, in der Regel einer logarithmischen oder inversen Funktion, und dann diese neue Merit-Funktion nach nach absteigendem $\mu$ zu lösen. \texttt{fmincon} verwendet eine logarithmische Barrierefunktion.

Das Innere-Punkte-Verfahren erzeugt im Gegensatz zu SQP eine eine Folge von streng zulässigen Iterierten, die zu einer Lösung aus dem Inneren der zulässigen Menge konvergieren.

Der \textit{MATLAB Optimization User's Guide} enthält einige Empfehlungen, wann welcher Algorithmus verwendet werden sollte. Die erste Empfehlung lautet, das Innere-Punkte-Verfahren für sowohl große, dünn besetzte Probleme als auch kleine und dichte Probleme zu verwenden. Außerdem werden bei allen Iterationen Schranken gesetzt und \texttt{NaN}- und \texttt{Inf}-Ergebnisse verarbeitet. Für kleinere Probleme ist SQP schneller.

Gradientenbasierte Methoden haben einige Einschränkungen. Das offensichtlichste Problem ist, dass sie voraussetzen, dass die Zielfunktion und die Nebenbedingungen kontinuierlich sind und kontinuierliche erste Ableitungen haben. Dies bedeutet im Wesentlichen, dass die Funktion keine logischen Verzweigungen haben darf, deterministisch sein muss und die Ausgaben gleichmäßig mit den Eingaben variieren müssen. 

FMINCON verlangt, dass die Zielfunktion und die Nebenbedingungsfunktion in getrennten Funktionen vorliegen. Dies führt zu einer verlängerten Laufzeit, da sowohl die Nebenbedingungen als auch das Ziel die Dynamik an jedem Gitterpunkt bewerten müssen.

\textit{MATLAB} bietet dem Benutzer die Möglichkeit, den Gradienten der Zielfunktion und die Nebenbedingungen parallel zu berechnen. Die Auswertungen der Zielfunktion und der Nebenbedingungen in dem Schema mit finiten Differenzen werden auf die Prozessoren verteilt. Weitere Informationen zur parallelen Implementierung finden Sie im MathWorks Optimization Toolbox User's Guide (2012).


\section{Schiessverfahren}

Was wird verwendet:
Anfangswert probleme mit einschritt verfahren explizit und implizit
Sensitivitäts DGL
Zusammenbau in Schiessverfahren


\section{Aufbau des Lösers}
Das Optimalsteuerungsproblem wurde mit einem direkten Lösungsverfahren und einem indirekten Lösungsverfahren gelöst. Zudem wurden die Untersuchungen in \autoref{sec:num_ode} separat implementiert. Um viel Code wiederverwenden zu können, sind die Löser mit einer Klassenstruktur implementiert. Hierbei ist die Ausgabe über die Klasse \verb+Plotter+ für alle Verfahren wiederverwendbar.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{images/03_TechnischeUmsetzung/code_structure}
    \caption{Schematische Darstellung der Implementierten Verfahren. Es wurde ein direktes und ein indirektes Lösungsverfahren implementiert. Alle Verfahren verwenden eine gemeinsame Ausgabe über die Klasse \texttt{Plotter}}
    \label{fig:code_structure}
\end{figure}


\section{Diskussion der numerischen Versuche und Ergebnisse mit direkten Lösungsverfahren}
Das Optimalsteuerungsproblem \ref{prob:MaxRF} mit den Parametern aus Tabelle \ref{tab:ProblemPara} wurden in die Form von Problem \ref{prob:EndNichtOpt} gebracht und technisch in Anhang \ref{Anhang:DirektV} mit MATLAB umgesetzt. 

Da mit den Grundeinstellungen des Optimalsteuerungsproblems \ref{prob:MaxRF} keine zufriedenstellende Ergebnisse erreicht werden konnten (siehe Versuch \ref{kap:Versuch0}), wurden verschiedene Versuche aufgestellt. In den nachfolgenden Versuchen \ref{kap:Versuch1}, \ref{kap:Versuch2}, \ref{kap:Versuch3} und \ref{kap:Versuch4} wurden verschiedene Parameter variiert, beziehungsweise neue Parameter und Beschränkungen eingeführt.

Plausible Ergebnisse, nach dem Aspekt der physikalischen Möglichkeiten, wurden in den Versuchen \ref{kap:Versuch11}, \ref{kap:Versuch31} und  \ref{kap:Versuch41} erreicht. Ausschlaggebender Parameter stellt die Endzeit $t_f$ dar, welche über die Qualität des Ergebnisses bestimmt.

Wie ist der Code / technische Umsetzung 

Versuche / Probleme 

Ergebnisse


Gedanken wie der Verlauf aussehen könnte:\\
Am Anfang maximaler Schub und maximaler Auftriebsbeiwert, um so schnell wie möglich die gewünschte Reisehöhe zu erhalten. Auftriebsbeiwert kann dann reduziert werden, um die Geschwindigkeit zu erhöhen. Dies bewirkt eine höhere Geschwindigkeit, wodurch die zurückgelegte Strecke maximiert wird.



\section{Diskussion der numerischen Versuche und Ergebnisse mit indirekten Lösungsverfahren}
Jedoch behandelt das Zweipunkt-Randwertproblem keine Bedingungen wie die Beschränkung des Staudrucks $q(v(t),h(t)) \leq q_{\max}$, wie in Problem \ref{prob:MaxRF} gefordert. Untersuchungen der Ergebnisse aus den Versuchen \ref{kap:Versuch11}, \ref{kap:Versuch31} und  \ref{kap:Versuch41} haben gezeigt, dass diese zu keinem Zeitpunkt den maximalen Wert $q_{\max}$ der Beschränkung erreicht haben (Abbildung \ref{img:test_1_1_staudruck}). Aus Vereinfachungsgründen, wird diese Beschränkung deshalb in diesem Kapitel nicht weiter berücksichtigt.




Die Jacobimatrix F

invertierbar ist. In der Losung y des Randwertproblems ist die Invertierbarkeit dieser Matrix eng verknupft mit der Mangasarian-Fromowitz-Regularitatsbedingung
fur Optimalsteuerungsprobleme.
